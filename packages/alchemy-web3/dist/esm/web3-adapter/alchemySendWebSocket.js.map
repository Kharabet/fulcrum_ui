{"version":3,"file":"alchemySendWebSocket.js","sourceRoot":"","sources":["../../../src/web3-adapter/alchemySendWebSocket.ts"],"names":[],"mappings":"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","sourcesContent":["import SturdyWebSocket from \"sturdy-websocket\";\r\nimport {\r\n  isResponse,\r\n  JsonRpcId,\r\n  JsonRpcRequest,\r\n  SingleOrBatchRequest,\r\n  SingleOrBatchResponse,\r\n  WebSocketMessage,\r\n} from \"../types\";\r\nimport { AlchemySendFunction, AlchemySendResult } from \"./alchemySend\";\r\n\r\ninterface RequestContext {\r\n  request: SingleOrBatchRequest;\r\n  resolve(response: AlchemySendResult): void;\r\n}\r\n\r\nexport function makeWebSocketSender(ws: SturdyWebSocket): AlchemySendFunction {\r\n  const contextsById = new Map<JsonRpcId, RequestContext>();\r\n  ws.addEventListener(\"message\", message => {\r\n    const response: WebSocketMessage = JSON.parse(message.data);\r\n    if (!isResponse(response)) {\r\n      return;\r\n    }\r\n    const id = getIdFromResponse(response);\r\n    if (id === undefined) {\r\n      return;\r\n    }\r\n    const context = contextsById.get(id);\r\n    if (!context) {\r\n      return;\r\n    }\r\n    const { resolve } = context;\r\n    contextsById.delete(id);\r\n    if (\r\n      !Array.isArray(response) &&\r\n      response.error &&\r\n      response.error.code === 429\r\n    ) {\r\n      resolve({ type: \"rateLimit\" });\r\n    } else {\r\n      resolve({ response, type: \"jsonrpc\" });\r\n    }\r\n  });\r\n  ws.addEventListener(\"down\", () => {\r\n    [...contextsById].forEach(([id, { request, resolve }]) => {\r\n      if (isWrite(request)) {\r\n        // Writes cannot be resent because they will fail for a duplicate nonce.\r\n        contextsById.delete(id);\r\n        resolve({\r\n          type: \"networkError\",\r\n          status: 0,\r\n          message: `WebSocket closed before receiving a response for write request with id: ${id}.`,\r\n        });\r\n      }\r\n    });\r\n  });\r\n  ws.addEventListener(\"reopen\", () => {\r\n    for (const { request } of contextsById.values()) {\r\n      ws.send(JSON.stringify(request));\r\n    }\r\n  });\r\n\r\n  return request =>\r\n    new Promise(resolve => {\r\n      const id = getIdFromRequest(request);\r\n      if (id !== undefined) {\r\n        const existingContext = contextsById.get(id);\r\n        if (existingContext) {\r\n          const message = `Another WebSocket request was made with the same id (${id}) before a response was received.`;\r\n          console.error(message);\r\n          existingContext.resolve({\r\n            message,\r\n            type: \"networkError\",\r\n            status: 0,\r\n          });\r\n        }\r\n        contextsById.set(id, { request, resolve });\r\n      }\r\n      ws.send(JSON.stringify(request));\r\n    });\r\n}\r\n\r\nfunction getIdFromRequest(\r\n  request: SingleOrBatchRequest,\r\n): JsonRpcId | undefined {\r\n  if (!Array.isArray(request)) {\r\n    return request.id;\r\n  }\r\n  return getCanonicalIdFromList(request.map(p => p.id));\r\n}\r\n\r\nfunction getIdFromResponse(\r\n  response: SingleOrBatchResponse,\r\n): JsonRpcId | undefined {\r\n  if (!Array.isArray(response)) {\r\n    return response.id;\r\n  }\r\n  return getCanonicalIdFromList(response.map(p => p.id));\r\n}\r\n\r\n/**\r\n * Since the JSON-RPC spec allows responses to be returned in a different order\r\n * than sent, we need a mechanism for choosing a canonical id from a list that\r\n * doesn't depend on the order. This chooses the \"minimum\" id by an arbitrary\r\n * ordering: the smallest string if possible, otherwise the smallest number,\r\n * otherwise null.\r\n */\r\nfunction getCanonicalIdFromList(\r\n  ids: Array<JsonRpcId | undefined>,\r\n): JsonRpcId | undefined {\r\n  const stringIds: string[] = ids.filter(id => typeof id === \"string\") as any;\r\n  if (stringIds.length > 0) {\r\n    return stringIds.reduce((bestId, id) => (bestId < id ? bestId : id));\r\n  }\r\n  const numberIds: number[] = ids.filter(id => typeof id === \"number\") as any;\r\n  if (numberIds.length > 0) {\r\n    return Math.min(...numberIds);\r\n  }\r\n  return ids.indexOf(null) >= 0 ? null : undefined;\r\n}\r\n\r\nfunction isWrite(request: SingleOrBatchRequest): boolean {\r\n  return Array.isArray(request)\r\n    ? request.every(isSingleWrite)\r\n    : isSingleWrite(request);\r\n}\r\n\r\nconst WRITE_METHODS = [\"eth_sendTransaction\", \"eth_sendRawTransaction\"];\r\n\r\nfunction isSingleWrite(request: JsonRpcRequest): boolean {\r\n  return WRITE_METHODS.includes(request.method);\r\n}\r\n"]}