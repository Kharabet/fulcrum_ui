{"version":3,"file":"sendPayload.js","sourceRoot":"","sources":["../../../src/web3-adapter/sendPayload.ts"],"names":[],"mappings":"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","sourcesContent":["import assertNever from \"assert-never\";\r\nimport {\r\n  Eip1193Provider,\r\n  FullConfig,\r\n  JsonRpcRequest,\r\n  JsonRpcResponse,\r\n  Provider,\r\n  SingleOrBatchRequest,\r\n  SingleOrBatchResponse,\r\n} from \"../types\";\r\nimport { delay, promisify } from \"../util/promises\";\r\nimport { AlchemySendFunction } from \"./alchemySend\";\r\n\r\nconst ALCHEMY_DISALLOWED_METHODS: string[] = [\r\n  \"eth_accounts\",\r\n  \"eth_sendRawTransaction\",\r\n  \"eth_sendTransaction\",\r\n  \"eth_sign\",\r\n  \"eth_signTypedData_v3\",\r\n  \"eth_signTypedData\",\r\n  \"personal_sign\",\r\n];\r\n\r\nexport interface PayloadSender {\r\n  sendPayload: SendPayloadFunction;\r\n  setWriteProvider(writeProvider: Provider | null | undefined): void;\r\n}\r\n\r\nexport interface SendPayloadFunction {\r\n  (payload: JsonRpcRequest): Promise<JsonRpcResponse>;\r\n  (payload: SingleOrBatchRequest): Promise<SingleOrBatchResponse>;\r\n}\r\n\r\nexport function makePayloadSender(\r\n  alchemySend: AlchemySendFunction,\r\n  config: FullConfig,\r\n): PayloadSender {\r\n  let currentWriteProvider = getEip1193Provider(config.writeProvider);\r\n\r\n  const sendPayload = (\r\n    payload: SingleOrBatchRequest,\r\n  ): Promise<SingleOrBatchResponse> => {\r\n    const disallowedMethod = getDisallowedMethod(payload);\r\n    if (!disallowedMethod) {\r\n      try {\r\n        return sendWithRetries(payload, alchemySend, config);\r\n      } catch (alchemyError) {\r\n        // Fallback to write provider, but if both fail throw the error from\r\n        // Alchemy.\r\n        if (!currentWriteProvider) {\r\n          throw alchemyError;\r\n        }\r\n        try {\r\n          return sendWithProvider(currentWriteProvider, payload);\r\n        } catch {\r\n          throw alchemyError;\r\n        }\r\n      }\r\n    } else {\r\n      if (!currentWriteProvider) {\r\n        throw new Error(\r\n          `No provider available for method \"${disallowedMethod}\"`,\r\n        );\r\n      }\r\n      return sendWithProvider(currentWriteProvider, payload);\r\n    }\r\n  };\r\n\r\n  function setWriteProvider(writeProvider: Provider | null | undefined) {\r\n    currentWriteProvider = getEip1193Provider(writeProvider);\r\n  }\r\n\r\n  return { sendPayload: sendPayload as SendPayloadFunction, setWriteProvider };\r\n}\r\n\r\nfunction getEip1193Provider(\r\n  provider: Provider | null | undefined,\r\n): Eip1193Provider | undefined {\r\n  if (!provider) {\r\n    return undefined;\r\n  }\r\n  const anyProvider: any = provider;\r\n  let nextId = 0;\r\n  const sendMethod = (anyProvider.sendAsync\r\n    ? anyProvider.sendAsync\r\n    : anyProvider.send\r\n  ).bind(anyProvider);\r\n  return {\r\n    send: (method, params) =>\r\n      promisify(callback =>\r\n        sendMethod(\r\n          { jsonrpc: \"2.0\", id: `legacy:${nextId++}`, method, params },\r\n          callback,\r\n        ),\r\n      ),\r\n  };\r\n}\r\n\r\nfunction sendWithProvider(\r\n  provider: Eip1193Provider,\r\n  payload: SingleOrBatchRequest,\r\n): Promise<SingleOrBatchResponse> {\r\n  if (!Array.isArray(payload)) {\r\n    const { method, params } = payload;\r\n    return provider.send(method, params);\r\n  } else {\r\n    // These providers don't support batches, sadly.\r\n    return Promise.all(\r\n      payload.map(({ method, params }) => provider.send(method, params)),\r\n    );\r\n  }\r\n}\r\n\r\nfunction getDisallowedMethod(\r\n  payload: SingleOrBatchRequest,\r\n): string | undefined {\r\n  const payloads = Array.isArray(payload) ? payload : [payload];\r\n  const disallowedRequest =\r\n    payloads.find(p => ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0) ||\r\n    undefined;\r\n  return disallowedRequest && disallowedRequest.method;\r\n}\r\n\r\nasync function sendWithRetries(\r\n  payload: SingleOrBatchRequest,\r\n  alchemySend: AlchemySendFunction,\r\n  { maxRetries, retryInterval, retryJitter }: FullConfig,\r\n): Promise<SingleOrBatchResponse> {\r\n  for (let i = 0; i < maxRetries + 1; i++) {\r\n    const result = await alchemySend(payload);\r\n    switch (result.type) {\r\n      case \"jsonrpc\":\r\n        return result.response;\r\n      case \"rateLimit\":\r\n        break;\r\n      case \"networkError\": {\r\n        const { status, message } = result;\r\n        const statusString = status !== 0 ? `(${status}) ` : \"\";\r\n        throw new Error(`${statusString} ${message}`);\r\n      }\r\n      default:\r\n        return assertNever(result);\r\n    }\r\n    await delay(retryInterval + ((retryJitter * Math.random()) | 0));\r\n  }\r\n  throw new Error(`Rate limited for ${maxRetries + 1} consecutive attempts.`);\r\n}\r\n"]}