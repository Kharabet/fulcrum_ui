{"version":3,"file":"webSocketProvider.js","sourceRoot":"","sources":["../../../src/web3-adapter/webSocketProvider.ts"],"names":[],"mappings":"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","sourcesContent":["import EventEmitter from \"eventemitter3\";\r\nimport SturdyWebSocket from \"sturdy-websocket\";\r\nimport {\r\n  Backfiller,\r\n  dedupeLogs,\r\n  dedupeNewHeads,\r\n  LogsEvent,\r\n  LogsSubscriptionFilter,\r\n  makeBackfiller,\r\n  NewHeadsEvent,\r\n} from \"../subscriptions/subscriptionBackfill\";\r\nimport {\r\n  isSubscriptionEvent,\r\n  JsonRpcRequest,\r\n  SendFunction,\r\n  SubscriptionEvent,\r\n  WebSocketMessage,\r\n} from \"../types\";\r\nimport { fromHex } from \"../util/hex\";\r\nimport {\r\n  JsonRpcSenders,\r\n  makePayloadFactory,\r\n  makeSenders,\r\n} from \"../util/jsonRpc\";\r\nimport {\r\n  makeCancelToken,\r\n  throwIfCancelled,\r\n  withBackoffRetries,\r\n  withTimeout,\r\n} from \"../util/promises\";\r\nimport { SendPayloadFunction } from \"./sendPayload\";\r\n\r\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n\r\n/**\r\n * This is the undocumented interface required by Web3 for providers which\r\n * handle subscriptions.\r\n *\r\n * In addition to the stated methods here, it communicates subscription events\r\n * by using EventEmitter#emit() to emit the events, with the appropriate\r\n * subscription id as the event type.\r\n */\r\nexport interface Web3SubscriptionProvider extends EventEmitter {\r\n  sendPayload: SendPayloadFunction;\r\n  send(method: string, params?: any[]): Promise<any>;\r\n  sendBatch(methods: any[], moduleInstance: any): Promise<any>;\r\n  supportsSubscriptions(): true;\r\n  subscribe(\r\n    subscribeMethod: string | undefined,\r\n    subscriptionMethod: string,\r\n    parameters: any[],\r\n  ): Promise<string>;\r\n  unsubscribe(\r\n    subscriptionId: string,\r\n    unsubscribeMethod?: string,\r\n  ): Promise<boolean>;\r\n  disconnect(code?: number, reason?: string): void;\r\n}\r\n\r\ninterface VirtualSubscription {\r\n  virtualId: string;\r\n  physicalId: string;\r\n  method: string;\r\n  params: any[];\r\n  isBackfilling: boolean;\r\n  startingBlockNumber: number;\r\n  sentEvents: any[];\r\n  backfillBuffer: any[];\r\n}\r\n\r\ninterface NewHeadsSubscription extends VirtualSubscription {\r\n  method: \"eth_subscribe\";\r\n  params: [\"newHeads\"];\r\n  isBackfilling: boolean;\r\n  sentEvents: NewHeadsEvent[];\r\n  backfillBuffer: NewHeadsEvent[];\r\n}\r\n\r\ninterface LogsSubscription extends VirtualSubscription {\r\n  method: \"eth_subscribe\";\r\n  params: [\"logs\", LogsSubscriptionFilter?];\r\n  isBackfilling: boolean;\r\n  sentEvents: LogsEvent[];\r\n  backfillBuffer: LogsEvent[];\r\n}\r\n\r\nexport class AlchemyWebSocketProvider extends EventEmitter\r\n  implements Web3SubscriptionProvider {\r\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n  // create new ones to replace them, but we want to create the illusion that\r\n  // the original subscriptions persist. Thus, maintain a mapping from the\r\n  // \"virtual\" subscription ids which are visible to the consumer to the\r\n  // \"physical\" subscription ids of the actual connections. This terminology is\r\n  // borrowed from virtual and physical memory, which has a similar mapping.\r\n  private readonly virtualSubscriptionsById: Map<\r\n    string,\r\n    VirtualSubscription\r\n  > = new Map();\r\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\r\n  private readonly makePayload = makePayloadFactory();\r\n  private readonly senders: JsonRpcSenders;\r\n  private readonly backfiller: Backfiller;\r\n  private heartbeatIntervalId?: NodeJS.Timeout;\r\n  private cancelBackfill = noop;\r\n\r\n  constructor(\r\n    private readonly ws: SturdyWebSocket,\r\n    public readonly sendPayload: SendPayloadFunction,\r\n  ) {\r\n    super();\r\n    this.senders = makeSenders(sendPayload, this.makePayload);\r\n    this.backfiller = makeBackfiller(this.senders);\r\n    this.send = this.senders.send;\r\n    this.addSocketListeners();\r\n    this.startHeartbeat();\r\n  }\r\n\r\n  public supportsSubscriptions(): true {\r\n    return true;\r\n  }\r\n\r\n  public async subscribe(\r\n    subscribeMethod = \"eth_subscribe\",\r\n    subscriptionMethod: string,\r\n    parameters: any[],\r\n  ): Promise<string> {\r\n    const method = subscribeMethod;\r\n    const params = [subscriptionMethod, ...parameters];\r\n    const startingBlockNumber = await this.getBlockNumber();\r\n    const id = await this.send(method, params);\r\n    this.virtualSubscriptionsById.set(id, {\r\n      method,\r\n      params,\r\n      startingBlockNumber,\r\n      virtualId: id,\r\n      physicalId: id,\r\n      sentEvents: [],\r\n      isBackfilling: false,\r\n      backfillBuffer: [],\r\n    });\r\n    this.virtualIdsByPhysicalId.set(id, id);\r\n    return id;\r\n  }\r\n\r\n  public async unsubscribe(\r\n    subscriptionId: string,\r\n    unsubscribeMethod = \"eth_unsubscribe\",\r\n  ): Promise<boolean> {\r\n    const virtualSubscription = this.virtualSubscriptionsById.get(\r\n      subscriptionId,\r\n    );\r\n    if (!virtualSubscription) {\r\n      return false;\r\n    }\r\n    const { physicalId } = virtualSubscription;\r\n    const response = await this.send(unsubscribeMethod, [physicalId]);\r\n    this.virtualSubscriptionsById.delete(subscriptionId);\r\n    this.virtualIdsByPhysicalId.delete(physicalId);\r\n    return response;\r\n  }\r\n\r\n  public disconnect(code?: number, reason?: string): void {\r\n    this.removeSocketListeners();\r\n    this.removeAllListeners();\r\n    this.stopHeartbeatAndBackfill();\r\n    this.ws.close(code, reason);\r\n  }\r\n\r\n  // tslint:disable-next-line: member-ordering\r\n  public readonly send: SendFunction;\r\n\r\n  public sendBatch(methods: any[], moduleInstance: any): Promise<any> {\r\n    const payload: JsonRpcRequest[] = [];\r\n    methods.forEach(method => {\r\n      method.beforeExecution(moduleInstance);\r\n      payload.push(this.makePayload(method.rpcMethod, method.parameters));\r\n    });\r\n    return this.sendPayload(payload);\r\n  }\r\n\r\n  private addSocketListeners(): void {\r\n    this.ws.addEventListener(\"message\", this.handleMessage);\r\n    this.ws.addEventListener(\"reopen\", this.handleReopen);\r\n    this.ws.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\r\n  }\r\n\r\n  private removeSocketListeners(): void {\r\n    this.ws.removeEventListener(\"message\", this.handleMessage);\r\n    this.ws.removeEventListener(\"reopen\", this.handleReopen);\r\n    this.ws.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\r\n  }\r\n\r\n  private startHeartbeat = (): void => {\r\n    if (this.heartbeatIntervalId != null) {\r\n      return;\r\n    }\r\n    this.heartbeatIntervalId = setInterval(async () => {\r\n      try {\r\n        await withTimeout(this.send(\"net_version\"), HEARTBEAT_WAIT_TIME);\r\n      } catch {\r\n        this.ws.reconnect();\r\n      }\r\n    }, HEARTBEAT_INTERVAL);\r\n  };\r\n\r\n  private stopHeartbeatAndBackfill = (): void => {\r\n    if (this.heartbeatIntervalId != null) {\r\n      clearInterval(this.heartbeatIntervalId);\r\n      this.heartbeatIntervalId = undefined;\r\n    }\r\n    this.cancelBackfill();\r\n  };\r\n\r\n  private handleMessage = (event: MessageEvent): void => {\r\n    const message: WebSocketMessage = JSON.parse(event.data);\r\n    if (!isSubscriptionEvent(message)) {\r\n      return;\r\n    }\r\n    const physicalId = message.params.subscription;\r\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n    if (!virtualId) {\r\n      return;\r\n    }\r\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\r\n    if (subscription.method !== \"eth_subscribe\") {\r\n      this.emitGenericEvent(virtualId, message.params.result);\r\n      return;\r\n    }\r\n    switch (subscription.params[0]) {\r\n      case \"newHeads\": {\r\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\r\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\r\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n        const { result } = newHeadsMessage.params;\r\n        if (isBackfilling) {\r\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n        } else {\r\n          this.emitNewHeadsEvent(virtualId, result);\r\n        }\r\n        break;\r\n      }\r\n      case \"logs\": {\r\n        const logsSubscription = subscription as LogsSubscription;\r\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\r\n        const { isBackfilling, backfillBuffer } = logsSubscription;\r\n        const { result } = logsMessage.params;\r\n        if (isBackfilling) {\r\n          addToLogsEventsBuffer(backfillBuffer, result);\r\n        } else {\r\n          this.emitLogsEvent(virtualId, result);\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n        this.emitGenericEvent(virtualId, message.params.result);\r\n    }\r\n  };\r\n\r\n  private handleReopen = (): void => {\r\n    this.virtualIdsByPhysicalId.clear();\r\n    const { cancel, isCancelled } = makeCancelToken();\r\n    this.cancelBackfill = cancel;\r\n    for (const subscription of this.virtualSubscriptionsById.values()) {\r\n      (async () => {\r\n        try {\r\n          await this.resubscribeAndBackfill(isCancelled, subscription);\r\n        } catch (error) {\r\n          if (!isCancelled()) {\r\n            console.error(\r\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\r\n              error,\r\n            );\r\n          }\r\n        }\r\n      })();\r\n    }\r\n    this.startHeartbeat();\r\n  };\r\n\r\n  private async resubscribeAndBackfill(\r\n    isCancelled: () => boolean,\r\n    subscription: VirtualSubscription,\r\n  ): Promise<void> {\r\n    const {\r\n      virtualId,\r\n      method,\r\n      params,\r\n      sentEvents,\r\n      backfillBuffer,\r\n      startingBlockNumber,\r\n    } = subscription;\r\n    subscription.isBackfilling = true;\r\n    backfillBuffer.length = 0;\r\n    try {\r\n      const physicalId = await this.send(method, params);\r\n      throwIfCancelled(isCancelled);\r\n      subscription.physicalId = physicalId;\r\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n      switch (params[0]) {\r\n        case \"newHeads\": {\r\n          const backfillEvents = await withBackoffRetries(\r\n            () =>\r\n              withTimeout(\r\n                this.backfiller.getNewHeadsBackfill(\r\n                  isCancelled,\r\n                  sentEvents,\r\n                  startingBlockNumber,\r\n                ),\r\n                BACKFILL_TIMEOUT,\r\n              ),\r\n            BACKFILL_RETRIES,\r\n            () => !isCancelled(),\r\n          );\r\n          throwIfCancelled(isCancelled);\r\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n          break;\r\n        }\r\n        case \"logs\": {\r\n          const filter: LogsSubscriptionFilter = params[1] || {};\r\n          const backfillEvents = await withBackoffRetries(\r\n            () =>\r\n              withTimeout(\r\n                this.backfiller.getLogsBackfill(\r\n                  isCancelled,\r\n                  filter,\r\n                  sentEvents,\r\n                  startingBlockNumber,\r\n                ),\r\n                BACKFILL_TIMEOUT,\r\n              ),\r\n            BACKFILL_RETRIES,\r\n            () => !isCancelled(),\r\n          );\r\n          throwIfCancelled(isCancelled);\r\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n          break;\r\n        }\r\n        default:\r\n          break;\r\n      }\r\n    } finally {\r\n      subscription.isBackfilling = false;\r\n      backfillBuffer.length = 0;\r\n    }\r\n  }\r\n\r\n  private async getBlockNumber(): Promise<number> {\r\n    const blockNumberHex: string = await this.send(\"eth_blockNumber\");\r\n    return fromHex(blockNumberHex);\r\n  }\r\n\r\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\r\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n  }\r\n\r\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\r\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n  }\r\n\r\n  /**\r\n   * Emits an event to consumers, but also remembers it in its subscriptions's\r\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n   * and needs to be reconnected.\r\n   */\r\n  private emitAndRememberEvent<T>(\r\n    virtualId: string,\r\n    result: T,\r\n    getBlockNumber: (result: T) => number,\r\n  ): void {\r\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n    if (!subscription) {\r\n      return;\r\n    }\r\n    // Web3 modifies these event objects once we pass them on (changing hex\r\n    // numbers to numbers). We want the original event, so make a defensive\r\n    // copy.\r\n    addToPastEventsBuffer(\r\n      subscription.sentEvents,\r\n      { ...result },\r\n      getBlockNumber,\r\n    );\r\n    this.emitGenericEvent(virtualId, result);\r\n  }\r\n\r\n  private emitGenericEvent(virtualId: string, result: any): void {\r\n    const event: SubscriptionEvent[\"params\"] = {\r\n      subscription: virtualId,\r\n      result,\r\n    };\r\n    this.emit(virtualId, event);\r\n  }\r\n}\r\n\r\nfunction addToNewHeadsEventsBuffer(\r\n  pastEvents: NewHeadsEvent[],\r\n  event: NewHeadsEvent,\r\n): void {\r\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\n\r\nfunction addToLogsEventsBuffer(\r\n  pastEvents: LogsEvent[],\r\n  event: LogsEvent,\r\n): void {\r\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n\r\n/**\r\n * Adds a new event to an array of events, evicting any events which\r\n * are so old that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer<T>(\r\n  pastEvents: T[],\r\n  event: T,\r\n  getBlockNumber: (event: T) => number,\r\n): void {\r\n  const currentBlockNumber = getBlockNumber(event);\r\n  // Find first index of an event recent enough to retain, then drop everything\r\n  // at a lower index.\r\n  const firstGoodIndex = pastEvents.findIndex(\r\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT,\r\n  );\r\n  if (firstGoodIndex === -1) {\r\n    pastEvents.length = 0;\r\n  } else {\r\n    pastEvents.splice(0, firstGoodIndex);\r\n  }\r\n  pastEvents.push(event);\r\n}\r\n\r\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\r\n  return fromHex(event.number);\r\n}\r\n\r\nfunction getLogsBlockNumber(event: LogsEvent): number {\r\n  return fromHex(event.blockNumber);\r\n}\r\n\r\nfunction noop(): void {\r\n  // Nothing.\r\n}\r\n"]}