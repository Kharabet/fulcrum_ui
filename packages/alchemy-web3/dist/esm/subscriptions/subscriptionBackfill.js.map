{"version":3,"file":"subscriptionBackfill.js","sourceRoot":"","sources":["../../../src/subscriptions/subscriptionBackfill.ts"],"names":[],"mappings":"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","sourcesContent":["import { fromHex, toHex } from \"../util/hex\";\r\nimport { BatchPart, JsonRpcSenders } from \"../util/jsonRpc\";\r\nimport { throwIfCancelled } from \"../util/promises\";\r\n\r\nexport interface NewHeadsEvent {\r\n  author: string;\r\n  difficulty: string;\r\n  extraData: string;\r\n  gasLimit: string;\r\n  gasUsed: string;\r\n  hash: string;\r\n  logsBloom: string;\r\n  miner: string;\r\n  mixHash: string;\r\n  nonce: string;\r\n  number: string;\r\n  parentHash: string;\r\n  receiptsRoot: string;\r\n  sealFields: string[];\r\n  sha3Uncles: string;\r\n  size: string;\r\n  stateRoot: string;\r\n  timestamp: string;\r\n  transactionsRoot: string;\r\n}\r\n\r\n/**\r\n * The return type of eth_getBlocksByHash.\r\n */\r\nexport interface BlockHead extends NewHeadsEvent {\r\n  totalDifficulty: string;\r\n  transactions: any[];\r\n  uncles: string[];\r\n}\r\n\r\nexport interface LogsEvent {\r\n  address: string;\r\n  blockHash: string;\r\n  blockNumber: string;\r\n  data: string;\r\n  logIndex: string;\r\n  topics: string[];\r\n  transactionHash: string;\r\n  transactionIndex: string;\r\n  removed?: boolean;\r\n}\r\n\r\nexport interface LogsSubscriptionFilter {\r\n  address?: string | string[];\r\n  topics?: Array<string | string[] | null>;\r\n}\r\n\r\ninterface GetLogsOptions extends LogsSubscriptionFilter {\r\n  fromBlock?: string;\r\n  toBlock?: string;\r\n}\r\n\r\nexport type Backfiller = ReturnType<typeof makeBackfiller>;\r\n\r\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed\r\n * for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n\r\nexport function makeBackfiller(senders: JsonRpcSenders) {\r\n  return { getNewHeadsBackfill, getLogsBackfill };\r\n\r\n  async function getNewHeadsBackfill(\r\n    isCancelled: () => boolean,\r\n    previousHeads: NewHeadsEvent[],\r\n    fromBlockNumber: number,\r\n  ): Promise<NewHeadsEvent[]> {\r\n    throwIfCancelled(isCancelled);\r\n    const toBlockNumber = await getBlockNumber();\r\n    throwIfCancelled(isCancelled);\r\n    if (previousHeads.length === 0) {\r\n      return getHeadEventsInRange(\r\n        Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1,\r\n        toBlockNumber + 1,\r\n      );\r\n    }\r\n    const lastSeenBlockNumber = fromHex(\r\n      previousHeads[previousHeads.length - 1].number,\r\n    );\r\n    const minBlockNumber = Math.max(\r\n      0,\r\n      lastSeenBlockNumber - MAX_BACKFILL_BLOCKS,\r\n    );\r\n    if (lastSeenBlockNumber < minBlockNumber) {\r\n      return getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n    }\r\n    const reorgHeads: NewHeadsEvent[] = await getReorgHeads(\r\n      isCancelled,\r\n      previousHeads,\r\n    );\r\n    throwIfCancelled(isCancelled);\r\n    const intermediateHeads: NewHeadsEvent[] = await getHeadEventsInRange(\r\n      lastSeenBlockNumber + 1,\r\n      toBlockNumber + 1,\r\n    );\r\n    throwIfCancelled(isCancelled);\r\n    return [...reorgHeads, ...intermediateHeads];\r\n  }\r\n\r\n  async function getReorgHeads(\r\n    isCancelled: () => boolean,\r\n    previousHeads: NewHeadsEvent[],\r\n  ): Promise<NewHeadsEvent[]> {\r\n    const result: NewHeadsEvent[] = [];\r\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n      const oldEvent = previousHeads[i];\r\n      const blockHead = await getBlockByNumber(fromHex(oldEvent.number));\r\n      throwIfCancelled(isCancelled);\r\n      if (oldEvent.hash === blockHead.hash) {\r\n        break;\r\n      }\r\n      result.push(toNewHeadsEvent(blockHead));\r\n    }\r\n    return result.reverse();\r\n  }\r\n\r\n  async function getHeadEventsInRange(\r\n    fromBlockInclusive: number,\r\n    toBlockExclusive: number,\r\n  ): Promise<NewHeadsEvent[]> {\r\n    if (fromBlockInclusive >= toBlockExclusive) {\r\n      return [];\r\n    }\r\n    const batchParts: BatchPart[] = [];\r\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n      batchParts.push({\r\n        method: \"eth_getBlockByNumber\",\r\n        params: [toHex(i), false],\r\n      });\r\n    }\r\n    const heads = await senders.sendBatch(batchParts);\r\n    return heads.map(toNewHeadsEvent);\r\n  }\r\n\r\n  async function getBlockByNumber(blockNumber: number): Promise<BlockHead> {\r\n    return senders.send(\"eth_getBlockByNumber\", [toHex(blockNumber), false]);\r\n  }\r\n\r\n  async function getLogsBackfill(\r\n    isCancelled: () => boolean,\r\n    filter: LogsSubscriptionFilter,\r\n    previousLogs: LogsEvent[],\r\n    fromBlockNumber: number,\r\n  ): Promise<LogsEvent[]> {\r\n    throwIfCancelled(isCancelled);\r\n    const toBlockNumber = await getBlockNumber();\r\n    throwIfCancelled(isCancelled);\r\n    if (previousLogs.length === 0) {\r\n      return getLogsInRange(\r\n        filter,\r\n        Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1,\r\n        toBlockNumber + 1,\r\n      );\r\n    }\r\n    const lastSeenBlockNumber = fromHex(\r\n      previousLogs[previousLogs.length - 1].blockNumber,\r\n    );\r\n    const minBlockNumber = Math.max(\r\n      0,\r\n      lastSeenBlockNumber - MAX_BACKFILL_BLOCKS,\r\n    );\r\n    if (lastSeenBlockNumber < minBlockNumber) {\r\n      return getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n    }\r\n    const commonAncestorNumber = await getCommonAncestorNumber(\r\n      isCancelled,\r\n      previousLogs,\r\n    );\r\n    throwIfCancelled(isCancelled);\r\n    const removedLogs = previousLogs\r\n      .filter(log => fromHex(log.blockNumber) > commonAncestorNumber)\r\n      .map(log => ({ ...log, removed: true }));\r\n    const addedLogs = await getLogsInRange(\r\n      filter,\r\n      commonAncestorNumber + 1,\r\n      toBlockNumber + 1,\r\n    );\r\n    throwIfCancelled(isCancelled);\r\n    return [...removedLogs, ...addedLogs];\r\n  }\r\n\r\n  async function getCommonAncestorNumber(\r\n    isCancelled: () => boolean,\r\n    previousLogs: LogsEvent[],\r\n  ): Promise<number> {\r\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n      const { blockHash, blockNumber } = previousLogs[i];\r\n      const { hash } = await getBlockByNumber(fromHex(blockNumber));\r\n      throwIfCancelled(isCancelled);\r\n      if (blockHash === hash) {\r\n        return fromHex(blockNumber);\r\n      }\r\n    }\r\n    return Number.NEGATIVE_INFINITY;\r\n  }\r\n\r\n  async function getLogsInRange(\r\n    filter: LogsSubscriptionFilter,\r\n    fromBlockInclusive: number,\r\n    toBlockExclusive: number,\r\n  ): Promise<LogsEvent[]> {\r\n    if (fromBlockInclusive >= toBlockExclusive) {\r\n      return [];\r\n    }\r\n    const rangeFilter: GetLogsOptions = {\r\n      ...filter,\r\n      fromBlock: toHex(fromBlockInclusive),\r\n      toBlock: toHex(toBlockExclusive - 1),\r\n    };\r\n    return senders.send(\"eth_getLogs\", [rangeFilter]);\r\n  }\r\n\r\n  async function getBlockNumber(): Promise<number> {\r\n    const blockNumberHex: string = await senders.send(\"eth_blockNumber\");\r\n    return fromHex(blockNumberHex);\r\n  }\r\n}\r\n\r\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\r\n  const result = { ...head };\r\n  delete result.totalDifficulty;\r\n  delete result.transactions;\r\n  delete result.uncles;\r\n  return result;\r\n}\r\n\r\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\r\n  return dedupe(events, event => event.hash);\r\n}\r\n\r\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\r\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\n\r\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\r\n  const keysSeen: Set<any> = new Set();\r\n  const result: T[] = [];\r\n  items.forEach(item => {\r\n    const key = getKey(item);\r\n    if (!keysSeen.has(key)) {\r\n      keysSeen.add(key);\r\n      result.push(item);\r\n    }\r\n  });\r\n  return result;\r\n}\r\n"]}