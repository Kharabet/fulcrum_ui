{"version":3,"file":"trezor-connector.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import { ConnectorUpdate } from '@web3-react/types'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport Web3ProviderEngine from 'web3-provider-engine'\nimport { TrezorSubprovider } from '@0x/subproviders/lib/src/subproviders/trezor' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport CacheSubprovider from 'web3-provider-engine/subproviders/cache.js'\nimport { RPCSubprovider } from '@0x/subproviders/lib/src/subproviders/rpc_subprovider' // https://github.com/0xProject/0x-monorepo/issues/1400\n\ninterface TrezorConnectorArguments {\n  chainId: number\n  url: string\n  pollingInterval?: number\n  requestTimeoutMs?: number\n  config?: any\n  manifestEmail: string\n  manifestAppUrl: string\n}\n\nexport class TrezorConnector extends AbstractConnector {\n  private readonly chainId: number\n  private readonly url: string\n  private readonly pollingInterval?: number\n  private readonly requestTimeoutMs?: number\n  private readonly config: any\n  private readonly manifestEmail: string\n  private readonly manifestAppUrl: string\n\n  private provider: any\n\n  constructor({\n    chainId,\n    url,\n    pollingInterval,\n    requestTimeoutMs,\n    config = {},\n    manifestEmail,\n    manifestAppUrl\n  }: TrezorConnectorArguments) {\n    super({ supportedChainIds: [chainId] })\n\n    this.chainId = chainId\n    this.url = url\n    this.pollingInterval = pollingInterval\n    this.requestTimeoutMs = requestTimeoutMs\n    this.config = config\n    this.manifestEmail = manifestEmail\n    this.manifestAppUrl = manifestAppUrl\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    if (!this.provider) {\n      const TrezorConnect = await import('trezor-connect').then(m => m?.default ?? m)\n      TrezorConnect.manifest({\n        email: this.manifestEmail,\n        appUrl: this.manifestAppUrl\n      })\n      const engine = new Web3ProviderEngine({ pollingInterval: this.pollingInterval })\n      engine.addProvider(new TrezorSubprovider({ trezorConnectClientApi: TrezorConnect, ...this.config }))\n      engine.addProvider(new CacheSubprovider())\n      engine.addProvider(new RPCSubprovider(this.url, this.requestTimeoutMs))\n      this.provider = engine\n    }\n\n    this.provider.start()\n\n    return { provider: this.provider, chainId: this.chainId }\n  }\n\n  public async getProvider(): Promise<Web3ProviderEngine> {\n    return this.provider\n  }\n\n  public async getChainId(): Promise<number> {\n    return this.chainId\n  }\n\n  public async getAccount(): Promise<null> {\n    return this.provider._providers[0].getAccountsAsync(1).then((accounts: string[]): string => accounts[0])\n  }\n\n  public deactivate() {\n    this.provider.stop()\n  }\n}\n"],"names":["chainId","url","pollingInterval","requestTimeoutMs","config","manifestEmail","manifestAppUrl","supportedChainIds","activate","this","provider","start","_this3","then","m","TrezorConnect","manifest","email","appUrl","engine","Web3ProviderEngine","addProvider","TrezorSubprovider","trezorConnectClientApi","CacheSubprovider","RPCSubprovider","getProvider","getChainId","getAccount","_providers","getAccountsAsync","accounts","deactivate","stop","AbstractConnector"],"mappings":"2sBA6BIA,IAAAA,QACAC,IAAAA,IACAC,IAAAA,gBACAC,IAAAA,qBACAC,OAAAA,aAAS,KACTC,IAAAA,cACAC,IAAAA,oCAEM,CAAEC,kBAAmB,CAACP,YAEvBA,QAAUA,IACVC,IAAMA,IACNC,gBAAkBA,IAClBC,iBAAmBA,IACnBC,OAASA,IACTC,cAAgBA,IAChBC,eAAiBA,+GAGXE,8BACNC,2BAaAC,SAASC,QAEP,CAAED,SAAUE,EAAKF,SAAUV,QAASY,EAAKZ,2BAf3CY,EAAKF,gCACoB,8QAAO,uBAAkBG,MAAK,SAAAC,+BAAKA,SAAAA,aAAcA,qBAAvEC,GACNA,EAAcC,SAAS,CACrBC,MAAOL,EAAKP,cACZa,OAAQN,EAAKN,qBAETa,EAAS,IAAIC,EAAmB,CAAElB,gBAAiBU,EAAKV,kBAC9DiB,EAAOE,YAAY,IAAIC,uBAAoBC,uBAAwBR,GAAkBH,EAAKR,UAC1Fe,EAAOE,YAAY,IAAIG,GACvBL,EAAOE,YAAY,IAAII,iBAAeb,EAAKX,IAAKW,EAAKT,qBAChDO,SAAWS,8FAQPO,kDACJjB,KAAKC,gDAGDiB,iDACJlB,KAAKT,+CAGD4B,iDACJnB,KAAKC,SAASmB,WAAW,GAAGC,iBAAiB,GAAGjB,MAAK,SAACkB,UAA+BA,EAAS,6CAGhGC,WAAA,gBACAtB,SAASuB,WA/DmBC"}